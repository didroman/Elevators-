class Lift:
    def __init__(self, current_floor=1):
        self.current_floor = current_floor  # Текущий этаж лифта
        self.tasks = []  # Очередь задач лифта

    def add_tasks(self, tasks):
        for task in tasks:
            if task.strip():  # Проверка на пустую строку
                self.tasks.append(int(task))  # Добавление задач в очередь лифта

    def move(self):
        if self.tasks:  # Если есть задачи в очереди
            # Сортировка задач по расстоянию до текущего этажа лифта (используя эвристическую оценку)
            self.tasks.sort(key=lambda x: abs(x - self.current_floor))

            target_floor = self.tasks.pop(0)  # Извлекаем первую задачу из очереди
            while self.current_floor != target_floor:  # Пока не достигнут целевой этаж
                if self.current_floor < target_floor:  # Если целевой этаж выше текущего
                    self.current_floor += 1  # Поднимаем лифт на этаж выше
                else:
                    self.current_floor -= 1  # Иначе опускаем лифт на этаж ниже
                print(f"Lift is on floor {self.current_floor}.")  # Вывод текущего этажа
                tasks_input = input("Введите номера этажей для лифта через запятую (или 'стоп' для завершения): ")
                if tasks_input.lower() == 'стоп':
                    break
                tasks = tasks_input.split(',')
                self.add_tasks(tasks)  # Добавляем новые задачи в очередь

            print(f"Lift stopped at floor {self.current_floor}.")  # Остановка лифта на целевом этаже
        else:
            print("No more tasks for the lift.")  # Если задач в очереди нет

    def remaining_tasks_estimate(self):
        return len(self.tasks)  # Возвращает количество задач в очереди

    def current_position_graph(self):
        floors = 10  # Общее количество этажей
        graph = ""
        for i in range(1, floors + 1):
            if i == self.current_floor:
                graph += f"({i})"  # Текущий этаж в скобках для графического представления
            else:
                graph += str(i)
            if i != floors:
                graph += "--"  # Разделитель между этажами в графе
        return graph

lift = Lift()  # Создание экземпляра класса Lift

steps = 0  # Счетчик шагов
stops = 0  # Счетчик остановок

while True:
    tasks_input = input("Введите номера этажей для лифта через запятую (или 'стоп' для завершения): ")
    if tasks_input.lower() == 'стоп':
        break
    tasks = tasks_input.split(',')  # Разделение введенных задач по запятой
    lift.add_tasks(tasks)  # Добавление задач в очередь

    lift.move()  # Выполнение задач лифтом

    steps += 1  # Увеличение счетчика шагов
    stops += 1  # Увеличение счетчика остановок

    print(f"Пройдено шагов: {steps}")  # Вывод количества пройденных шагов
    print(f"Остановок: {stops}")  # Вывод количества остановок
    print(f"Задач в очереди: {lift.remaining_tasks_estimate()}")  # Вывод количества задач в очереди
    print(f"Оценка оставшихся циклов до завершения задач в очереди: {lift.remaining_tasks_estimate() + stops}")  # Оценка оставшихся циклов до завершения всех задач
    print(f"Текущее положение лифта в формате графа: {lift.current_position_graph()}")  # Графическое представление текущего положения лифта

print("Работа лифта завершена.")
